# Frontend Fundamentals 모의고사 <적금 계산기 🧮>

사용자가 입력한 **목표 금액 / 월 납입액 / 저축 기간**을 바탕으로  
조건에 맞는 적금 상품을 탐색하고, 계산 결과(예상 금액, 목표 대비 차이, 추천 월 납입액, 추천 상품)를 제공하는 서비스입니다.

## ⬛️ 구현 목표

- 서비스의 유지보수 및 장기적인 확장성을 고려한 설계·추상화 중심 구현을 목표로 합니다.
- 사용자 관점에서 불편하거나 혼란스러울 수 있는 지점을 고려합니다.
- 요구사항이 명확하지 않은 부분에 대해서는 합리적인 가설을 세우고 그 전제를 코드와 문서로 명시합니다.

## ⬛️ 컴포넌트 아키텍처 설계

### 1️⃣ 전체 아키텍처 흐름

```
SavingsCalculatorPage (페이지 / 컨테이너)
 ├─ 상태: 입력값, 탭, 기간
 ├─ 데이터: useGetProductList()
 │
 ▼
TabContents (탭 공통 상태 관리)
 ├─ 상태: checkedProductId
 ├─ 상태 제어: setCheckedProduct
 ├─ 필터링 데이터: filteredData (useMemo)
 │
 ├─ selectedTab === 'products'
 │      ▼
 │   SavingsProducts (상품 탭 UI)
 │   └─ ProductRow (리스트)
 │
 └─ selectedTab === 'results'
        ▼
     SavingsResults (결과 탭 UI)
     ├─ 계산 로직
     └─ ProductRow (추천 상품)

```

### 2️⃣ 상태 범위에 따른 책임 분리

상태는 **어디까지 영향을 미치는지**를 기준으로 관리 위치를 결정했습니다.

- **페이지 전반에 영향을 미치는 상태**
  - 입력값, 탭 선택, 기간 선택
  - → `SavingsCalculatorPage`에서 관리
- **탭 간에 공유되어야 하는 비즈니스 상태**
  - 선택된 상품, 필터링 결과
  - → `TabContents`에서 관리
- **단순 표시를 위한 UI 단위**
  - → 각 Tab 컴포넌트 및 `ProductRow`

이를 통해

- 상태 변경의 영향 범위를 예측하기 쉬워지고
- 특정 기능 수정 시 다른 영역으로의 부수 효과를 최소화할 수 있습니다.

### 3️⃣ 데이터 흐름의 단방향 유지

데이터는 항상 **위에서 아래로만 흐르도록** 설계했습니다.

SavingsCalculatorPage  
↓  
TabContents  
↓  
SavingsProducts / SavingsResults  
↓  
ProductRow

- 하위 컴포넌트는 **상태를 직접 소유하지 않고**
- 상위 컴포넌트에서 전달받은 데이터와 콜백만 사용합니다.

이 구조는

- 컴포넌트 간 의존성을 단순화하고
- 디버깅 및 로직 추적을 쉽게 만들며
- React의 선언적 UI 패턴과도 자연스럽게 부합합니다.

## ⬛️ UX 개선 예정

### 1) 필수 입력값 누락 시 안내

- 목표 금액 또는 월 납입액이 입력되지 않았을 경우  
  **“목표 금액과 월 납입액을 입력해주세요”** 안내 문구를 노출할 예정입니다.

### 2) 결과 탭에서 선택 상품이 사라졌을 때 UX 개선

- 입력값 변경으로 인해 필터링 결과가 바뀌면  
  선택된 상품이 사라질 수 있습니다.
- 현재는 “상품을 선택해주세요” 문구만 노출되는데,
  - 이 경우 **적금 상품 탭으로 자동 이동**시키는 UX를 고려 중입니다.

### 3) 입력값 편집 UX 개선

- `50,000 → 30,000`처럼 자릿수를 수정할 때  
  자연스러운 숫자 편집이 가능하도록 입력 처리 로직을 개선할 예정입니다.  
  (현재는 특정 자릿수를 지우면 0으로 변경되는 문제가 있습니다.)

- 입력 중 결과 화면이 즉시 변경되어 맥락을 잃지 않도록 다음 전략을 검토 중입니다.
  - 디바운스 적용
  - 입력 확정 시 계산
  - `useDeferredValue` 적용

- 입력값을 한 번에 초기화할 수 있도록  
  **목표 금액 / 월 납입액 / 저축 기간을 리셋하는 버튼 제공**도 함께 검토 중입니다.

### 4) 필터링 실패 시 UX 처리

- 판단 배경
  - 적금 계산기의 목적은 **사용자가 적금 상품을 선택하도록 돕는 것**이라고 판단했습니다.
  - 필터링 조건에 맞는 상품이 없을 때  
    “조건에 맞는 상품이 없습니다” 안내만으로는 다음 행동을 유도하기 어렵다고 보았습니다.

- 사용자 관점 문제
  - 입력한 금액이나 기간이 시장 상품 범위와 얼마나 다른지 알기 어렵습니다.
  - 어떤 방향으로 조건을 수정해야 할지 판단하기 힘듭니다.

- 개선 방향
  - 필터링 실패 시 안내 문구와 함께  
    **전체 상품 목록 또는 추천 가능한 일부 상품을 함께 노출**할 예정입니다.
  - 이를 통해 사용자가
    - 실제 상품의 월 납입액/기간 기준을 확인하고
    - 입력값 조정 방향에 대한 힌트를 얻을 수 있도록 할 예정입니다.

- 확장성 고려
  - 상품 수가 많아질 경우 정보 과부하를 방지하기 위해
    - 상위 추천 상품 3개 우선 노출
    - “전체 상품 보기” 확장 버튼 제공
    - 필요 시 페이징 또는 리스트 가상화 적용을 고려합니다.

## ⬛️ 유지보수 개선 예정

### 1. 표시값과 계산값 분리

현재는 입력값을 콤마가 포함된 문자열로 상태에 저장하고 있어  
계산 시마다 `Number(removeComma(value))`를 반복 사용하고 있습니다.

향후에는

- 상태는 **숫자(number)** 로만 관리하고
- 화면 렌더링 시에만 포맷(`formatCurrency`)을 적용하며
- 입력 시에는 1회 파싱(`parseCurrency`)만 수행하는 구조로 개선할 예정입니다.

이를 통해 계산/필터링 로직에서 문자열 파싱을 제거하고,  
입력 UX와 계산 로직의 책임을 명확히 분리하려고 합니다.

## ⬛️ 성능 최적화

### 컴포넌트 리렌더링 최소화

- 상품 리스트의 각 Row를 `ProductRow` 컴포넌트로 분리했습니다.
- `memo`를 적용하여 **체크 상태가 변경된 row만 리렌더링**되도록 했습니다.

또한

- 이벤트 핸들러(`setCheckedProduct`)는 `useCallback`으로 참조를 고정해  
  리스트 전체 리렌더링을 방지했습니다.

## ⬛️ UX 개선 완료

### 1. 계산 결과 탭에서 상품 토글 방지

- 초기 구현
  - 상품 선택을 강제하지 않는 것이 더 자연스럽다고 판단했습니다.
  - 이에 따라 선택/해제가 가능한 토글 구조로 설계했습니다.

- 문제점
  - 계산 결과 탭에서 상품을 해제하면
    - 선택된 상품이 사라지고
    - 계산 결과도 함께 사라져 결과 확인 흐름이 끊기는 문제가 발생했습니다.

- 개선 내용
  - 계산 결과 탭에서는 상품 선택 해제를 비활성화했습니다.
  - 선택 상태를 유지한 채 다른 상품으로만 변경 가능하도록 UX를 개선했습니다.

## ⬛️ 계산 로직 및 가설

### 추천 월 납입액 한도 보정

상품의 최소/최대 월 납입 범위로 보정합니다.

추천 월 납입액은 목표 금액 기준으로 계산되지만,
이 값이 상품의 실제 가입 조건을 벗어날 수 있습니다.

- 목표 금액이 큰 경우 → 추천 월 납입 금액이 상품 최대 월 납입 금액을 초과
- 목표 금액이 작은 경우 → 추천 월 납입 금액이 0이 나올 수 있음

```ts
const recommendedMonthlyAmount = Math.min(maxMonthlyAmount, Math.max(minMonthlyAmount, roundedMonthlyAmount));
```
